---
title: 'Reflection after taking EECS 482: Introduction to Operating System'
date: 2020-01-03
permalink: /posts/2020/01/blog-post-1/
tags:
  - course reflection
  - eecs 482
---

The biggest challenge for my last semester was to take EECS 482, the Introduction to Operating System, one of the hardest courses offered at the University of Michigan. This course is known for the heavy workload that comes along with projects, tough exams, and bad letter grades compared to other upper-level courses offered at UofM.


Before the course
======

I hesitated before I was determined whether I should take this course. A primary reason was whether this course is helpful if I am not "system-side" people. If I end up doing software development, machine learning or some other fields in computer science, would it be worth taking this course? Besides, according to some of my friends who had previously taken this course, the professors were tough about the letter grade compared to most of the other upper-level courses, and I did not want the course to spoil my GPA.


However, the operating system is like the fundamental components for software that runs on the computer. Thus, the knowledge of operating systems has interactions with many fields such as embedded systems, distributed systems, networking and so on. Even for machine learning, the system side work could leverage the speed of algorithms such as the process of training neural networks. Another evidence is that previously, the operating system course is required for every computer science student at UofM, which shows the importance of this course.

As for the letter grade, after thinking for a while, I realized it was stupid to focus on GPA. GPA is nothing other than a floating-point number. What matters the most is the skills you hone and the knowledge you learn in class, not the letter grade you earn or the GPA you receive.

After all the thinking, I was determined to take this course.

When taking the course
======

I would not deny that it was painful when I took the course. Though the functional codes are not that long, however, the bug could be everywhere. For instance, in project 2, we were to implement a multi-CPU thread library with interrupt enabled. For a single CPU, you might be able to set the random seed to a certain number and carry out the whole testing and debugging process. But when you arrived at the multi-CPU world, congratulations, it is non-deterministic inherently. To debug such code, either you could examine code by raw eyes, or you could put a bunch of print statements and execute the program enough times (that your bug and the cause of the bug could be exposed). In this specific project, since it is not code-heavy compared to the Pager and File system, examining code by raw eyes is not that bad as it sounds. By careful thinking through the logic, you could probably come up with the reason why your program fails. 

An important reason behind annoying bugs in the thread library could be caused by the lack of understanding concepts. The reason behind a bug that trapped us several days was that the thread object and the thread execution are separate. The correct understanding should be that: we take advantage of thread object to spawn an execution of a thread, after that, these two are never related. Based on this interesting setup, a new way is required to deal with "cleaning up" the thread execution that is created by us.

For project 3, in which we implemented the pager that manages the virtual pages, the most challenging bug that bothered me was from an edge case. At the very end of this project, we passed all the six credit cases, but 2 four-credit cases were left. Well, debugging edge cases with raw eyes is no more useful in this one, and my team got stuck on this for several days since we seemed to exhaust all possible ways of writing testing programs, and our program passed all the local cases we wrote. Finally, I used gcov to generate a coverage report of our local testing. It turned out that two lines in our code were not tested by our local testing, and it was those two lines that caused our bug. The most important lesson I learned in project 3 probably was using tools to help yourself. It is really easy to generate gcov report, I am not lying, you can generate one with two lines of commands, and there are detailed tutorials online. But the outcome of using tools can astonish you.

It is not only about this project, if we think about the development of computer science, using tools is the key. Look at what we have now, the programming language is based on assembly, the higher programming language is based on lower ones. With programming, we built IDEs, version control tools (such as Github) that help us better develop software. In a broader sense, when the first human being wanted to survive, he sharpened stones, cut woods to hunt. And it is making tools and utilizing those tools that make him special, that make him distinguished from the rest of the animals.

For project 4, the most important lesson I learned was to arrange code wisely. This project, in which we built the file system, is the longest among all the projects. To better organize our code, I wrote several CPP files for different "layers" of the program. For instance, there could be a CPP file that uses the most fundamental lock and unlocks functions to provide a nicer, cleaner RAII interface for other programs to use. The other layer could use those interfaces and provide helper functions that only aim at realizing certain functionalities. Then the main program could manipulate with helper functions to achieve something big. 

The arrangement makes the code cleaner and self-explanatory for sure, and it can even help to debug. Since by distributing tasks to multiple layers, we could see what the assumption and what the output of a certain layer is. It is like a pipeline, and once every part of the pipeline works, the program works.

After the course
======

Thinking back to what I have gone through in this course, I would admit that I have learned a lot in it. There were challenges along the way, sometimes big challenges, but when I completed those projects which once seemed unattainable, the happiness I received was beyond word. Challenges are not barriers, they are the places of interest waiting to be explored.
